// This Source Form is subject to the terms of the AQUA Software License, v. 1.0.
// Copyright (c) 2024 Aymeric Wibo

// this file is automatically generated by 'aqua-devices/aquabsd.black/wgpu/gen.py'
// if you need to update this, read the 'aqua-devices/aquabsd.black/wgpu/README.md' document

#include <stdint.h>
#include "webgpu.h"

#include <aquabsd.alps/win/public.h>

typedef enum {
	CMD_SURFACE_FROM_WIN = 0x0000,

	// WebGPU commands

	CMD_wgpuCreateInstance = 0x1000,
	CMD_wgpuGetProcAddress = 0x1001,
	CMD_wgpuAdapterEnumerateFeatures = 0x1002,
	CMD_wgpuAdapterGetLimits = 0x1003,
	CMD_wgpuAdapterGetProperties = 0x1004,
	CMD_wgpuAdapterHasFeature = 0x1005,
	CMD_wgpuAdapterRequestDevice = 0x1006,
	CMD_wgpuAdapterReference = 0x1007,
	CMD_wgpuAdapterRelease = 0x1008,
	CMD_wgpuBindGroupSetLabel = 0x1009,
	CMD_wgpuBindGroupReference = 0x100a,
	CMD_wgpuBindGroupRelease = 0x100b,
	CMD_wgpuBindGroupLayoutSetLabel = 0x100c,
	CMD_wgpuBindGroupLayoutReference = 0x100d,
	CMD_wgpuBindGroupLayoutRelease = 0x100e,
	CMD_wgpuBufferDestroy = 0x100f,
	CMD_wgpuBufferGetConstMappedRange = 0x1010,
	CMD_wgpuBufferGetMapState = 0x1011,
	CMD_wgpuBufferGetMappedRange = 0x1012,
	CMD_wgpuBufferGetSize = 0x1013,
	CMD_wgpuBufferGetUsage = 0x1014,
	CMD_wgpuBufferMapAsync = 0x1015,
	CMD_wgpuBufferSetLabel = 0x1016,
	CMD_wgpuBufferUnmap = 0x1017,
	CMD_wgpuBufferReference = 0x1018,
	CMD_wgpuBufferRelease = 0x1019,
	CMD_wgpuCommandBufferSetLabel = 0x101a,
	CMD_wgpuCommandBufferReference = 0x101b,
	CMD_wgpuCommandBufferRelease = 0x101c,
	CMD_wgpuCommandEncoderBeginComputePass = 0x101d,
	CMD_wgpuCommandEncoderBeginRenderPass = 0x101e,
	CMD_wgpuCommandEncoderClearBuffer = 0x101f,
	CMD_wgpuCommandEncoderCopyBufferToBuffer = 0x1020,
	CMD_wgpuCommandEncoderCopyBufferToTexture = 0x1021,
	CMD_wgpuCommandEncoderCopyTextureToBuffer = 0x1022,
	CMD_wgpuCommandEncoderCopyTextureToTexture = 0x1023,
	CMD_wgpuCommandEncoderFinish = 0x1024,
	CMD_wgpuCommandEncoderInsertDebugMarker = 0x1025,
	CMD_wgpuCommandEncoderPopDebugGroup = 0x1026,
	CMD_wgpuCommandEncoderPushDebugGroup = 0x1027,
	CMD_wgpuCommandEncoderResolveQuerySet = 0x1028,
	CMD_wgpuCommandEncoderSetLabel = 0x1029,
	CMD_wgpuCommandEncoderWriteTimestamp = 0x102a,
	CMD_wgpuCommandEncoderReference = 0x102b,
	CMD_wgpuCommandEncoderRelease = 0x102c,
	CMD_wgpuComputePassEncoderBeginPipelineStatisticsQuery = 0x102d,
	CMD_wgpuComputePassEncoderDispatchWorkgroups = 0x102e,
	CMD_wgpuComputePassEncoderDispatchWorkgroupsIndirect = 0x102f,
	CMD_wgpuComputePassEncoderEnd = 0x1030,
	CMD_wgpuComputePassEncoderEndPipelineStatisticsQuery = 0x1031,
	CMD_wgpuComputePassEncoderInsertDebugMarker = 0x1032,
	CMD_wgpuComputePassEncoderPopDebugGroup = 0x1033,
	CMD_wgpuComputePassEncoderPushDebugGroup = 0x1034,
	CMD_wgpuComputePassEncoderSetBindGroup = 0x1035,
	CMD_wgpuComputePassEncoderSetLabel = 0x1036,
	CMD_wgpuComputePassEncoderSetPipeline = 0x1037,
	CMD_wgpuComputePassEncoderReference = 0x1038,
	CMD_wgpuComputePassEncoderRelease = 0x1039,
	CMD_wgpuComputePipelineGetBindGroupLayout = 0x103a,
	CMD_wgpuComputePipelineSetLabel = 0x103b,
	CMD_wgpuComputePipelineReference = 0x103c,
	CMD_wgpuComputePipelineRelease = 0x103d,
	CMD_wgpuDeviceCreateBindGroup = 0x103e,
	CMD_wgpuDeviceCreateBindGroupLayout = 0x103f,
	CMD_wgpuDeviceCreateBuffer = 0x1040,
	CMD_wgpuDeviceCreateCommandEncoder = 0x1041,
	CMD_wgpuDeviceCreateComputePipeline = 0x1042,
	CMD_wgpuDeviceCreateComputePipelineAsync = 0x1043,
	CMD_wgpuDeviceCreatePipelineLayout = 0x1044,
	CMD_wgpuDeviceCreateQuerySet = 0x1045,
	CMD_wgpuDeviceCreateRenderBundleEncoder = 0x1046,
	CMD_wgpuDeviceCreateRenderPipeline = 0x1047,
	CMD_wgpuDeviceCreateRenderPipelineAsync = 0x1048,
	CMD_wgpuDeviceCreateSampler = 0x1049,
	CMD_wgpuDeviceCreateShaderModule = 0x104a,
	CMD_wgpuDeviceCreateSwapChain = 0x104b,
	CMD_wgpuDeviceCreateTexture = 0x104c,
	CMD_wgpuDeviceDestroy = 0x104d,
	CMD_wgpuDeviceEnumerateFeatures = 0x104e,
	CMD_wgpuDeviceGetLimits = 0x104f,
	CMD_wgpuDeviceGetQueue = 0x1050,
	CMD_wgpuDeviceHasFeature = 0x1051,
	CMD_wgpuDevicePopErrorScope = 0x1052,
	CMD_wgpuDevicePushErrorScope = 0x1053,
	CMD_wgpuDeviceSetLabel = 0x1054,
	CMD_wgpuDeviceSetUncapturedErrorCallback = 0x1055,
	CMD_wgpuDeviceReference = 0x1056,
	CMD_wgpuDeviceRelease = 0x1057,
	CMD_wgpuInstanceCreateSurface = 0x1058,
	CMD_wgpuInstanceProcessEvents = 0x1059,
	CMD_wgpuInstanceRequestAdapter = 0x105a,
	CMD_wgpuInstanceReference = 0x105b,
	CMD_wgpuInstanceRelease = 0x105c,
	CMD_wgpuPipelineLayoutSetLabel = 0x105d,
	CMD_wgpuPipelineLayoutReference = 0x105e,
	CMD_wgpuPipelineLayoutRelease = 0x105f,
	CMD_wgpuQuerySetDestroy = 0x1060,
	CMD_wgpuQuerySetGetCount = 0x1061,
	CMD_wgpuQuerySetGetType = 0x1062,
	CMD_wgpuQuerySetSetLabel = 0x1063,
	CMD_wgpuQuerySetReference = 0x1064,
	CMD_wgpuQuerySetRelease = 0x1065,
	CMD_wgpuQueueOnSubmittedWorkDone = 0x1066,
	CMD_wgpuQueueSetLabel = 0x1067,
	CMD_wgpuQueueSubmit = 0x1068,
	CMD_wgpuQueueWriteBuffer = 0x1069,
	CMD_wgpuQueueWriteTexture = 0x106a,
	CMD_wgpuQueueReference = 0x106b,
	CMD_wgpuQueueRelease = 0x106c,
	CMD_wgpuRenderBundleSetLabel = 0x106d,
	CMD_wgpuRenderBundleReference = 0x106e,
	CMD_wgpuRenderBundleRelease = 0x106f,
	CMD_wgpuRenderBundleEncoderDraw = 0x1070,
	CMD_wgpuRenderBundleEncoderDrawIndexed = 0x1071,
	CMD_wgpuRenderBundleEncoderDrawIndexedIndirect = 0x1072,
	CMD_wgpuRenderBundleEncoderDrawIndirect = 0x1073,
	CMD_wgpuRenderBundleEncoderFinish = 0x1074,
	CMD_wgpuRenderBundleEncoderInsertDebugMarker = 0x1075,
	CMD_wgpuRenderBundleEncoderPopDebugGroup = 0x1076,
	CMD_wgpuRenderBundleEncoderPushDebugGroup = 0x1077,
	CMD_wgpuRenderBundleEncoderSetBindGroup = 0x1078,
	CMD_wgpuRenderBundleEncoderSetIndexBuffer = 0x1079,
	CMD_wgpuRenderBundleEncoderSetLabel = 0x107a,
	CMD_wgpuRenderBundleEncoderSetPipeline = 0x107b,
	CMD_wgpuRenderBundleEncoderSetVertexBuffer = 0x107c,
	CMD_wgpuRenderBundleEncoderReference = 0x107d,
	CMD_wgpuRenderBundleEncoderRelease = 0x107e,
	CMD_wgpuRenderPassEncoderBeginOcclusionQuery = 0x107f,
	CMD_wgpuRenderPassEncoderBeginPipelineStatisticsQuery = 0x1080,
	CMD_wgpuRenderPassEncoderDraw = 0x1081,
	CMD_wgpuRenderPassEncoderDrawIndexed = 0x1082,
	CMD_wgpuRenderPassEncoderDrawIndexedIndirect = 0x1083,
	CMD_wgpuRenderPassEncoderDrawIndirect = 0x1084,
	CMD_wgpuRenderPassEncoderEnd = 0x1085,
	CMD_wgpuRenderPassEncoderEndOcclusionQuery = 0x1086,
	CMD_wgpuRenderPassEncoderEndPipelineStatisticsQuery = 0x1087,
	CMD_wgpuRenderPassEncoderExecuteBundles = 0x1088,
	CMD_wgpuRenderPassEncoderInsertDebugMarker = 0x1089,
	CMD_wgpuRenderPassEncoderPopDebugGroup = 0x108a,
	CMD_wgpuRenderPassEncoderPushDebugGroup = 0x108b,
	CMD_wgpuRenderPassEncoderSetBindGroup = 0x108c,
	CMD_wgpuRenderPassEncoderSetBlendConstant = 0x108d,
	CMD_wgpuRenderPassEncoderSetIndexBuffer = 0x108e,
	CMD_wgpuRenderPassEncoderSetLabel = 0x108f,
	CMD_wgpuRenderPassEncoderSetPipeline = 0x1090,
	CMD_wgpuRenderPassEncoderSetScissorRect = 0x1091,
	CMD_wgpuRenderPassEncoderSetStencilReference = 0x1092,
	CMD_wgpuRenderPassEncoderSetVertexBuffer = 0x1093,
	CMD_wgpuRenderPassEncoderSetViewport = 0x1094,
	CMD_wgpuRenderPassEncoderReference = 0x1095,
	CMD_wgpuRenderPassEncoderRelease = 0x1096,
	CMD_wgpuRenderPipelineGetBindGroupLayout = 0x1097,
	CMD_wgpuRenderPipelineSetLabel = 0x1098,
	CMD_wgpuRenderPipelineReference = 0x1099,
	CMD_wgpuRenderPipelineRelease = 0x109a,
	CMD_wgpuSamplerSetLabel = 0x109b,
	CMD_wgpuSamplerReference = 0x109c,
	CMD_wgpuSamplerRelease = 0x109d,
	CMD_wgpuShaderModuleGetCompilationInfo = 0x109e,
	CMD_wgpuShaderModuleSetLabel = 0x109f,
	CMD_wgpuShaderModuleReference = 0x10a0,
	CMD_wgpuShaderModuleRelease = 0x10a1,
	CMD_wgpuSurfaceGetPreferredFormat = 0x10a2,
	CMD_wgpuSurfaceReference = 0x10a3,
	CMD_wgpuSurfaceRelease = 0x10a4,
	CMD_wgpuSwapChainGetCurrentTextureView = 0x10a5,
	CMD_wgpuSwapChainPresent = 0x10a6,
	CMD_wgpuSwapChainReference = 0x10a7,
	CMD_wgpuSwapChainRelease = 0x10a8,
	CMD_wgpuTextureCreateView = 0x10a9,
	CMD_wgpuTextureDestroy = 0x10aa,
	CMD_wgpuTextureGetDepthOrArrayLayers = 0x10ab,
	CMD_wgpuTextureGetDimension = 0x10ac,
	CMD_wgpuTextureGetFormat = 0x10ad,
	CMD_wgpuTextureGetHeight = 0x10ae,
	CMD_wgpuTextureGetMipLevelCount = 0x10af,
	CMD_wgpuTextureGetSampleCount = 0x10b0,
	CMD_wgpuTextureGetUsage = 0x10b1,
	CMD_wgpuTextureGetWidth = 0x10b2,
	CMD_wgpuTextureSetLabel = 0x10b3,
	CMD_wgpuTextureReference = 0x10b4,
	CMD_wgpuTextureRelease = 0x10b5,
	CMD_wgpuTextureViewSetLabel = 0x10b6,
	CMD_wgpuTextureViewReference = 0x10b7,
	CMD_wgpuTextureViewRelease = 0x10b8,
} cmd_t;

uint64_t (*kos_query_device) (uint64_t, uint64_t name);
void* (*kos_load_device_function) (uint64_t device, const char* name);
uint64_t (*kos_callback) (uint64_t callback, int argument_count, ...);

static uint64_t win_device = -1;

int load(void) {
	win_device = kos_query_device(0, (uint64_t) "aquabsd.alps.win");

	if (win_device != (uint64_t) -1) {
		aquabsd_alps_win_get_draw_win = kos_load_device_function(win_device, "get_draw_win");
	}

	return 0;
}

uint64_t send(uint16_t _cmd, void* data) {
	cmd_t const cmd = _cmd;

	if (cmd == CMD_SURFACE_FROM_WIN) {
		struct {
			WGPUInstance instance;
			aquabsd_alps_win_t* win;
		} __attribute__((packed))* const args = data;

		WGPUSurfaceDescriptorFromXcbWindow const descr_from_xcb = {
			.chain = (WGPUChainedStruct const) {
				.sType = WGPUSType_SurfaceDescriptorFromXcbWindow,
			},
			.connection = args->win->connection,
			.window = args->win->win,
		};

		WGPUSurfaceDescriptor const descr = {
			.nextInChain = (WGPUChainedStruct const*) &descr_from_xcb,
		};

		WGPUSurface const surface = wgpuInstanceCreateSurface(args->instance, &descr);
		return (uint64_t) surface;
	}
	
	else if (cmd == CMD_wgpuCreateInstance) {
		struct {
			WGPUInstanceDescriptor const * descriptor;
		} __attribute__((packed))* const args = data;

		return (uint64_t) wgpuCreateInstance(args->descriptor);
	}

	else if (cmd == CMD_wgpuGetProcAddress) {
		struct {
			WGPUDevice device;
			char const * procName;
		} __attribute__((packed))* const args = data;

		return (uint64_t) wgpuGetProcAddress(args->device, args->procName);
	}

	else if (cmd == CMD_wgpuAdapterEnumerateFeatures) {
		struct {
			WGPUAdapter adapter;
			WGPUFeatureName * features;
		} __attribute__((packed))* const args = data;

		return (uint64_t) wgpuAdapterEnumerateFeatures(args->adapter, args->features);
	}

	else if (cmd == CMD_wgpuAdapterGetLimits) {
		struct {
			WGPUAdapter adapter;
			WGPUSupportedLimits * limits;
		} __attribute__((packed))* const args = data;

		return (uint64_t) wgpuAdapterGetLimits(args->adapter, args->limits);
	}

	else if (cmd == CMD_wgpuAdapterGetProperties) {
		struct {
			WGPUAdapter adapter;
			WGPUAdapterProperties * properties;
		} __attribute__((packed))* const args = data;

		wgpuAdapterGetProperties(args->adapter, args->properties);
	}

	else if (cmd == CMD_wgpuAdapterHasFeature) {
		struct {
			WGPUAdapter adapter;
			WGPUFeatureName feature;
		} __attribute__((packed))* const args = data;

		return (uint64_t) wgpuAdapterHasFeature(args->adapter, args->feature);
	}

	else if (cmd == CMD_wgpuAdapterRequestDevice) {
		struct {
			WGPUAdapter adapter;
			WGPU_NULLABLE WGPUDeviceDescriptor const * descriptor;
			WGPURequestDeviceCallback callback;
			void * userdata;
		} __attribute__((packed))* const args = data;

		wgpuAdapterRequestDevice(args->adapter, args->descriptor, args->callback, args->userdata);
	}

	else if (cmd == CMD_wgpuAdapterReference) {
		struct {
			WGPUAdapter adapter;
		} __attribute__((packed))* const args = data;

		wgpuAdapterReference(args->adapter);
	}

	else if (cmd == CMD_wgpuAdapterRelease) {
		struct {
			WGPUAdapter adapter;
		} __attribute__((packed))* const args = data;

		wgpuAdapterRelease(args->adapter);
	}

	else if (cmd == CMD_wgpuBindGroupSetLabel) {
		struct {
			WGPUBindGroup bindGroup;
			char const * label;
		} __attribute__((packed))* const args = data;

		wgpuBindGroupSetLabel(args->bindGroup, args->label);
	}

	else if (cmd == CMD_wgpuBindGroupReference) {
		struct {
			WGPUBindGroup bindGroup;
		} __attribute__((packed))* const args = data;

		wgpuBindGroupReference(args->bindGroup);
	}

	else if (cmd == CMD_wgpuBindGroupRelease) {
		struct {
			WGPUBindGroup bindGroup;
		} __attribute__((packed))* const args = data;

		wgpuBindGroupRelease(args->bindGroup);
	}

	else if (cmd == CMD_wgpuBindGroupLayoutSetLabel) {
		struct {
			WGPUBindGroupLayout bindGroupLayout;
			char const * label;
		} __attribute__((packed))* const args = data;

		wgpuBindGroupLayoutSetLabel(args->bindGroupLayout, args->label);
	}

	else if (cmd == CMD_wgpuBindGroupLayoutReference) {
		struct {
			WGPUBindGroupLayout bindGroupLayout;
		} __attribute__((packed))* const args = data;

		wgpuBindGroupLayoutReference(args->bindGroupLayout);
	}

	else if (cmd == CMD_wgpuBindGroupLayoutRelease) {
		struct {
			WGPUBindGroupLayout bindGroupLayout;
		} __attribute__((packed))* const args = data;

		wgpuBindGroupLayoutRelease(args->bindGroupLayout);
	}

	else if (cmd == CMD_wgpuBufferDestroy) {
		struct {
			WGPUBuffer buffer;
		} __attribute__((packed))* const args = data;

		wgpuBufferDestroy(args->buffer);
	}

	else if (cmd == CMD_wgpuBufferGetConstMappedRange) {
		struct {
			WGPUBuffer buffer;
			size_t offset;
			size_t size;
		} __attribute__((packed))* const args = data;

		return (uint64_t) wgpuBufferGetConstMappedRange(args->buffer, args->offset, args->size);
	}

	else if (cmd == CMD_wgpuBufferGetMapState) {
		struct {
			WGPUBuffer buffer;
		} __attribute__((packed))* const args = data;

		return (uint64_t) wgpuBufferGetMapState(args->buffer);
	}

	else if (cmd == CMD_wgpuBufferGetMappedRange) {
		struct {
			WGPUBuffer buffer;
			size_t offset;
			size_t size;
		} __attribute__((packed))* const args = data;

		return (uint64_t) wgpuBufferGetMappedRange(args->buffer, args->offset, args->size);
	}

	else if (cmd == CMD_wgpuBufferGetSize) {
		struct {
			WGPUBuffer buffer;
		} __attribute__((packed))* const args = data;

		return (uint64_t) wgpuBufferGetSize(args->buffer);
	}

	else if (cmd == CMD_wgpuBufferGetUsage) {
		struct {
			WGPUBuffer buffer;
		} __attribute__((packed))* const args = data;

		return (uint64_t) wgpuBufferGetUsage(args->buffer);
	}

	else if (cmd == CMD_wgpuBufferMapAsync) {
		struct {
			WGPUBuffer buffer;
			WGPUMapModeFlags mode;
			size_t offset;
			size_t size;
			WGPUBufferMapCallback callback;
			void * userdata;
		} __attribute__((packed))* const args = data;

		wgpuBufferMapAsync(args->buffer, args->mode, args->offset, args->size, args->callback, args->userdata);
	}

	else if (cmd == CMD_wgpuBufferSetLabel) {
		struct {
			WGPUBuffer buffer;
			char const * label;
		} __attribute__((packed))* const args = data;

		wgpuBufferSetLabel(args->buffer, args->label);
	}

	else if (cmd == CMD_wgpuBufferUnmap) {
		struct {
			WGPUBuffer buffer;
		} __attribute__((packed))* const args = data;

		wgpuBufferUnmap(args->buffer);
	}

	else if (cmd == CMD_wgpuBufferReference) {
		struct {
			WGPUBuffer buffer;
		} __attribute__((packed))* const args = data;

		wgpuBufferReference(args->buffer);
	}

	else if (cmd == CMD_wgpuBufferRelease) {
		struct {
			WGPUBuffer buffer;
		} __attribute__((packed))* const args = data;

		wgpuBufferRelease(args->buffer);
	}

	else if (cmd == CMD_wgpuCommandBufferSetLabel) {
		struct {
			WGPUCommandBuffer commandBuffer;
			char const * label;
		} __attribute__((packed))* const args = data;

		wgpuCommandBufferSetLabel(args->commandBuffer, args->label);
	}

	else if (cmd == CMD_wgpuCommandBufferReference) {
		struct {
			WGPUCommandBuffer commandBuffer;
		} __attribute__((packed))* const args = data;

		wgpuCommandBufferReference(args->commandBuffer);
	}

	else if (cmd == CMD_wgpuCommandBufferRelease) {
		struct {
			WGPUCommandBuffer commandBuffer;
		} __attribute__((packed))* const args = data;

		wgpuCommandBufferRelease(args->commandBuffer);
	}

	else if (cmd == CMD_wgpuCommandEncoderBeginComputePass) {
		struct {
			WGPUCommandEncoder commandEncoder;
			WGPU_NULLABLE WGPUComputePassDescriptor const * descriptor;
		} __attribute__((packed))* const args = data;

		return (uint64_t) wgpuCommandEncoderBeginComputePass(args->commandEncoder, args->descriptor);
	}

	else if (cmd == CMD_wgpuCommandEncoderBeginRenderPass) {
		struct {
			WGPUCommandEncoder commandEncoder;
			WGPURenderPassDescriptor const * descriptor;
		} __attribute__((packed))* const args = data;

		return (uint64_t) wgpuCommandEncoderBeginRenderPass(args->commandEncoder, args->descriptor);
	}

	else if (cmd == CMD_wgpuCommandEncoderClearBuffer) {
		struct {
			WGPUCommandEncoder commandEncoder;
			WGPUBuffer buffer;
			uint64_t offset;
			uint64_t size;
		} __attribute__((packed))* const args = data;

		wgpuCommandEncoderClearBuffer(args->commandEncoder, args->buffer, args->offset, args->size);
	}

	else if (cmd == CMD_wgpuCommandEncoderCopyBufferToBuffer) {
		struct {
			WGPUCommandEncoder commandEncoder;
			WGPUBuffer source;
			uint64_t sourceOffset;
			WGPUBuffer destination;
			uint64_t destinationOffset;
			uint64_t size;
		} __attribute__((packed))* const args = data;

		wgpuCommandEncoderCopyBufferToBuffer(args->commandEncoder, args->source, args->sourceOffset, args->destination, args->destinationOffset, args->size);
	}

	else if (cmd == CMD_wgpuCommandEncoderCopyBufferToTexture) {
		struct {
			WGPUCommandEncoder commandEncoder;
			WGPUImageCopyBuffer const * source;
			WGPUImageCopyTexture const * destination;
			WGPUExtent3D const * copySize;
		} __attribute__((packed))* const args = data;

		wgpuCommandEncoderCopyBufferToTexture(args->commandEncoder, args->source, args->destination, args->copySize);
	}

	else if (cmd == CMD_wgpuCommandEncoderCopyTextureToBuffer) {
		struct {
			WGPUCommandEncoder commandEncoder;
			WGPUImageCopyTexture const * source;
			WGPUImageCopyBuffer const * destination;
			WGPUExtent3D const * copySize;
		} __attribute__((packed))* const args = data;

		wgpuCommandEncoderCopyTextureToBuffer(args->commandEncoder, args->source, args->destination, args->copySize);
	}

	else if (cmd == CMD_wgpuCommandEncoderCopyTextureToTexture) {
		struct {
			WGPUCommandEncoder commandEncoder;
			WGPUImageCopyTexture const * source;
			WGPUImageCopyTexture const * destination;
			WGPUExtent3D const * copySize;
		} __attribute__((packed))* const args = data;

		wgpuCommandEncoderCopyTextureToTexture(args->commandEncoder, args->source, args->destination, args->copySize);
	}

	else if (cmd == CMD_wgpuCommandEncoderFinish) {
		struct {
			WGPUCommandEncoder commandEncoder;
			WGPU_NULLABLE WGPUCommandBufferDescriptor const * descriptor;
		} __attribute__((packed))* const args = data;

		return (uint64_t) wgpuCommandEncoderFinish(args->commandEncoder, args->descriptor);
	}

	else if (cmd == CMD_wgpuCommandEncoderInsertDebugMarker) {
		struct {
			WGPUCommandEncoder commandEncoder;
			char const * markerLabel;
		} __attribute__((packed))* const args = data;

		wgpuCommandEncoderInsertDebugMarker(args->commandEncoder, args->markerLabel);
	}

	else if (cmd == CMD_wgpuCommandEncoderPopDebugGroup) {
		struct {
			WGPUCommandEncoder commandEncoder;
		} __attribute__((packed))* const args = data;

		wgpuCommandEncoderPopDebugGroup(args->commandEncoder);
	}

	else if (cmd == CMD_wgpuCommandEncoderPushDebugGroup) {
		struct {
			WGPUCommandEncoder commandEncoder;
			char const * groupLabel;
		} __attribute__((packed))* const args = data;

		wgpuCommandEncoderPushDebugGroup(args->commandEncoder, args->groupLabel);
	}

	else if (cmd == CMD_wgpuCommandEncoderResolveQuerySet) {
		struct {
			WGPUCommandEncoder commandEncoder;
			WGPUQuerySet querySet;
			uint32_t firstQuery;
			uint32_t queryCount;
			WGPUBuffer destination;
			uint64_t destinationOffset;
		} __attribute__((packed))* const args = data;

		wgpuCommandEncoderResolveQuerySet(args->commandEncoder, args->querySet, args->firstQuery, args->queryCount, args->destination, args->destinationOffset);
	}

	else if (cmd == CMD_wgpuCommandEncoderSetLabel) {
		struct {
			WGPUCommandEncoder commandEncoder;
			char const * label;
		} __attribute__((packed))* const args = data;

		wgpuCommandEncoderSetLabel(args->commandEncoder, args->label);
	}

	else if (cmd == CMD_wgpuCommandEncoderWriteTimestamp) {
		struct {
			WGPUCommandEncoder commandEncoder;
			WGPUQuerySet querySet;
			uint32_t queryIndex;
		} __attribute__((packed))* const args = data;

		wgpuCommandEncoderWriteTimestamp(args->commandEncoder, args->querySet, args->queryIndex);
	}

	else if (cmd == CMD_wgpuCommandEncoderReference) {
		struct {
			WGPUCommandEncoder commandEncoder;
		} __attribute__((packed))* const args = data;

		wgpuCommandEncoderReference(args->commandEncoder);
	}

	else if (cmd == CMD_wgpuCommandEncoderRelease) {
		struct {
			WGPUCommandEncoder commandEncoder;
		} __attribute__((packed))* const args = data;

		wgpuCommandEncoderRelease(args->commandEncoder);
	}

	else if (cmd == CMD_wgpuComputePassEncoderBeginPipelineStatisticsQuery) {
		struct {
			WGPUComputePassEncoder computePassEncoder;
			WGPUQuerySet querySet;
			uint32_t queryIndex;
		} __attribute__((packed))* const args = data;

		wgpuComputePassEncoderBeginPipelineStatisticsQuery(args->computePassEncoder, args->querySet, args->queryIndex);
	}

	else if (cmd == CMD_wgpuComputePassEncoderDispatchWorkgroups) {
		struct {
			WGPUComputePassEncoder computePassEncoder;
			uint32_t workgroupCountX;
			uint32_t workgroupCountY;
			uint32_t workgroupCountZ;
		} __attribute__((packed))* const args = data;

		wgpuComputePassEncoderDispatchWorkgroups(args->computePassEncoder, args->workgroupCountX, args->workgroupCountY, args->workgroupCountZ);
	}

	else if (cmd == CMD_wgpuComputePassEncoderDispatchWorkgroupsIndirect) {
		struct {
			WGPUComputePassEncoder computePassEncoder;
			WGPUBuffer indirectBuffer;
			uint64_t indirectOffset;
		} __attribute__((packed))* const args = data;

		wgpuComputePassEncoderDispatchWorkgroupsIndirect(args->computePassEncoder, args->indirectBuffer, args->indirectOffset);
	}

	else if (cmd == CMD_wgpuComputePassEncoderEnd) {
		struct {
			WGPUComputePassEncoder computePassEncoder;
		} __attribute__((packed))* const args = data;

		wgpuComputePassEncoderEnd(args->computePassEncoder);
	}

	else if (cmd == CMD_wgpuComputePassEncoderEndPipelineStatisticsQuery) {
		struct {
			WGPUComputePassEncoder computePassEncoder;
		} __attribute__((packed))* const args = data;

		wgpuComputePassEncoderEndPipelineStatisticsQuery(args->computePassEncoder);
	}

	else if (cmd == CMD_wgpuComputePassEncoderInsertDebugMarker) {
		struct {
			WGPUComputePassEncoder computePassEncoder;
			char const * markerLabel;
		} __attribute__((packed))* const args = data;

		wgpuComputePassEncoderInsertDebugMarker(args->computePassEncoder, args->markerLabel);
	}

	else if (cmd == CMD_wgpuComputePassEncoderPopDebugGroup) {
		struct {
			WGPUComputePassEncoder computePassEncoder;
		} __attribute__((packed))* const args = data;

		wgpuComputePassEncoderPopDebugGroup(args->computePassEncoder);
	}

	else if (cmd == CMD_wgpuComputePassEncoderPushDebugGroup) {
		struct {
			WGPUComputePassEncoder computePassEncoder;
			char const * groupLabel;
		} __attribute__((packed))* const args = data;

		wgpuComputePassEncoderPushDebugGroup(args->computePassEncoder, args->groupLabel);
	}

	else if (cmd == CMD_wgpuComputePassEncoderSetBindGroup) {
		struct {
			WGPUComputePassEncoder computePassEncoder;
			uint32_t groupIndex;
			WGPU_NULLABLE WGPUBindGroup group;
			size_t dynamicOffsetCount;
			uint32_t const * dynamicOffsets;
		} __attribute__((packed))* const args = data;

		wgpuComputePassEncoderSetBindGroup(args->computePassEncoder, args->groupIndex, args->group, args->dynamicOffsetCount, args->dynamicOffsets);
	}

	else if (cmd == CMD_wgpuComputePassEncoderSetLabel) {
		struct {
			WGPUComputePassEncoder computePassEncoder;
			char const * label;
		} __attribute__((packed))* const args = data;

		wgpuComputePassEncoderSetLabel(args->computePassEncoder, args->label);
	}

	else if (cmd == CMD_wgpuComputePassEncoderSetPipeline) {
		struct {
			WGPUComputePassEncoder computePassEncoder;
			WGPUComputePipeline pipeline;
		} __attribute__((packed))* const args = data;

		wgpuComputePassEncoderSetPipeline(args->computePassEncoder, args->pipeline);
	}

	else if (cmd == CMD_wgpuComputePassEncoderReference) {
		struct {
			WGPUComputePassEncoder computePassEncoder;
		} __attribute__((packed))* const args = data;

		wgpuComputePassEncoderReference(args->computePassEncoder);
	}

	else if (cmd == CMD_wgpuComputePassEncoderRelease) {
		struct {
			WGPUComputePassEncoder computePassEncoder;
		} __attribute__((packed))* const args = data;

		wgpuComputePassEncoderRelease(args->computePassEncoder);
	}

	else if (cmd == CMD_wgpuComputePipelineGetBindGroupLayout) {
		struct {
			WGPUComputePipeline computePipeline;
			uint32_t groupIndex;
		} __attribute__((packed))* const args = data;

		return (uint64_t) wgpuComputePipelineGetBindGroupLayout(args->computePipeline, args->groupIndex);
	}

	else if (cmd == CMD_wgpuComputePipelineSetLabel) {
		struct {
			WGPUComputePipeline computePipeline;
			char const * label;
		} __attribute__((packed))* const args = data;

		wgpuComputePipelineSetLabel(args->computePipeline, args->label);
	}

	else if (cmd == CMD_wgpuComputePipelineReference) {
		struct {
			WGPUComputePipeline computePipeline;
		} __attribute__((packed))* const args = data;

		wgpuComputePipelineReference(args->computePipeline);
	}

	else if (cmd == CMD_wgpuComputePipelineRelease) {
		struct {
			WGPUComputePipeline computePipeline;
		} __attribute__((packed))* const args = data;

		wgpuComputePipelineRelease(args->computePipeline);
	}

	else if (cmd == CMD_wgpuDeviceCreateBindGroup) {
		struct {
			WGPUDevice device;
			WGPUBindGroupDescriptor const * descriptor;
		} __attribute__((packed))* const args = data;

		return (uint64_t) wgpuDeviceCreateBindGroup(args->device, args->descriptor);
	}

	else if (cmd == CMD_wgpuDeviceCreateBindGroupLayout) {
		struct {
			WGPUDevice device;
			WGPUBindGroupLayoutDescriptor const * descriptor;
		} __attribute__((packed))* const args = data;

		return (uint64_t) wgpuDeviceCreateBindGroupLayout(args->device, args->descriptor);
	}

	else if (cmd == CMD_wgpuDeviceCreateBuffer) {
		struct {
			WGPUDevice device;
			WGPUBufferDescriptor const * descriptor;
		} __attribute__((packed))* const args = data;

		return (uint64_t) wgpuDeviceCreateBuffer(args->device, args->descriptor);
	}

	else if (cmd == CMD_wgpuDeviceCreateCommandEncoder) {
		struct {
			WGPUDevice device;
			WGPU_NULLABLE WGPUCommandEncoderDescriptor const * descriptor;
		} __attribute__((packed))* const args = data;

		return (uint64_t) wgpuDeviceCreateCommandEncoder(args->device, args->descriptor);
	}

	else if (cmd == CMD_wgpuDeviceCreateComputePipeline) {
		struct {
			WGPUDevice device;
			WGPUComputePipelineDescriptor const * descriptor;
		} __attribute__((packed))* const args = data;

		return (uint64_t) wgpuDeviceCreateComputePipeline(args->device, args->descriptor);
	}

	else if (cmd == CMD_wgpuDeviceCreateComputePipelineAsync) {
		struct {
			WGPUDevice device;
			WGPUComputePipelineDescriptor const * descriptor;
			WGPUCreateComputePipelineAsyncCallback callback;
			void * userdata;
		} __attribute__((packed))* const args = data;

		wgpuDeviceCreateComputePipelineAsync(args->device, args->descriptor, args->callback, args->userdata);
	}

	else if (cmd == CMD_wgpuDeviceCreatePipelineLayout) {
		struct {
			WGPUDevice device;
			WGPUPipelineLayoutDescriptor const * descriptor;
		} __attribute__((packed))* const args = data;

		return (uint64_t) wgpuDeviceCreatePipelineLayout(args->device, args->descriptor);
	}

	else if (cmd == CMD_wgpuDeviceCreateQuerySet) {
		struct {
			WGPUDevice device;
			WGPUQuerySetDescriptor const * descriptor;
		} __attribute__((packed))* const args = data;

		return (uint64_t) wgpuDeviceCreateQuerySet(args->device, args->descriptor);
	}

	else if (cmd == CMD_wgpuDeviceCreateRenderBundleEncoder) {
		struct {
			WGPUDevice device;
			WGPURenderBundleEncoderDescriptor const * descriptor;
		} __attribute__((packed))* const args = data;

		return (uint64_t) wgpuDeviceCreateRenderBundleEncoder(args->device, args->descriptor);
	}

	else if (cmd == CMD_wgpuDeviceCreateRenderPipeline) {
		struct {
			WGPUDevice device;
			WGPURenderPipelineDescriptor const * descriptor;
		} __attribute__((packed))* const args = data;

		return (uint64_t) wgpuDeviceCreateRenderPipeline(args->device, args->descriptor);
	}

	else if (cmd == CMD_wgpuDeviceCreateRenderPipelineAsync) {
		struct {
			WGPUDevice device;
			WGPURenderPipelineDescriptor const * descriptor;
			WGPUCreateRenderPipelineAsyncCallback callback;
			void * userdata;
		} __attribute__((packed))* const args = data;

		wgpuDeviceCreateRenderPipelineAsync(args->device, args->descriptor, args->callback, args->userdata);
	}

	else if (cmd == CMD_wgpuDeviceCreateSampler) {
		struct {
			WGPUDevice device;
			WGPU_NULLABLE WGPUSamplerDescriptor const * descriptor;
		} __attribute__((packed))* const args = data;

		return (uint64_t) wgpuDeviceCreateSampler(args->device, args->descriptor);
	}

	else if (cmd == CMD_wgpuDeviceCreateShaderModule) {
		struct {
			WGPUDevice device;
			WGPUShaderModuleDescriptor const * descriptor;
		} __attribute__((packed))* const args = data;

		return (uint64_t) wgpuDeviceCreateShaderModule(args->device, args->descriptor);
	}

	else if (cmd == CMD_wgpuDeviceCreateSwapChain) {
		struct {
			WGPUDevice device;
			WGPUSurface surface;
			WGPUSwapChainDescriptor const * descriptor;
		} __attribute__((packed))* const args = data;

		return (uint64_t) wgpuDeviceCreateSwapChain(args->device, args->surface, args->descriptor);
	}

	else if (cmd == CMD_wgpuDeviceCreateTexture) {
		struct {
			WGPUDevice device;
			WGPUTextureDescriptor const * descriptor;
		} __attribute__((packed))* const args = data;

		return (uint64_t) wgpuDeviceCreateTexture(args->device, args->descriptor);
	}

	else if (cmd == CMD_wgpuDeviceDestroy) {
		struct {
			WGPUDevice device;
		} __attribute__((packed))* const args = data;

		wgpuDeviceDestroy(args->device);
	}

	else if (cmd == CMD_wgpuDeviceEnumerateFeatures) {
		struct {
			WGPUDevice device;
			WGPUFeatureName * features;
		} __attribute__((packed))* const args = data;

		return (uint64_t) wgpuDeviceEnumerateFeatures(args->device, args->features);
	}

	else if (cmd == CMD_wgpuDeviceGetLimits) {
		struct {
			WGPUDevice device;
			WGPUSupportedLimits * limits;
		} __attribute__((packed))* const args = data;

		return (uint64_t) wgpuDeviceGetLimits(args->device, args->limits);
	}

	else if (cmd == CMD_wgpuDeviceGetQueue) {
		struct {
			WGPUDevice device;
		} __attribute__((packed))* const args = data;

		return (uint64_t) wgpuDeviceGetQueue(args->device);
	}

	else if (cmd == CMD_wgpuDeviceHasFeature) {
		struct {
			WGPUDevice device;
			WGPUFeatureName feature;
		} __attribute__((packed))* const args = data;

		return (uint64_t) wgpuDeviceHasFeature(args->device, args->feature);
	}

	else if (cmd == CMD_wgpuDevicePopErrorScope) {
		struct {
			WGPUDevice device;
			WGPUErrorCallback callback;
			void * userdata;
		} __attribute__((packed))* const args = data;

		wgpuDevicePopErrorScope(args->device, args->callback, args->userdata);
	}

	else if (cmd == CMD_wgpuDevicePushErrorScope) {
		struct {
			WGPUDevice device;
			WGPUErrorFilter filter;
		} __attribute__((packed))* const args = data;

		wgpuDevicePushErrorScope(args->device, args->filter);
	}

	else if (cmd == CMD_wgpuDeviceSetLabel) {
		struct {
			WGPUDevice device;
			char const * label;
		} __attribute__((packed))* const args = data;

		wgpuDeviceSetLabel(args->device, args->label);
	}

	else if (cmd == CMD_wgpuDeviceSetUncapturedErrorCallback) {
		struct {
			WGPUDevice device;
			WGPUErrorCallback callback;
			void * userdata;
		} __attribute__((packed))* const args = data;

		wgpuDeviceSetUncapturedErrorCallback(args->device, args->callback, args->userdata);
	}

	else if (cmd == CMD_wgpuDeviceReference) {
		struct {
			WGPUDevice device;
		} __attribute__((packed))* const args = data;

		wgpuDeviceReference(args->device);
	}

	else if (cmd == CMD_wgpuDeviceRelease) {
		struct {
			WGPUDevice device;
		} __attribute__((packed))* const args = data;

		wgpuDeviceRelease(args->device);
	}

	else if (cmd == CMD_wgpuInstanceCreateSurface) {
		struct {
			WGPUInstance instance;
			WGPUSurfaceDescriptor const * descriptor;
		} __attribute__((packed))* const args = data;

		return (uint64_t) wgpuInstanceCreateSurface(args->instance, args->descriptor);
	}

	else if (cmd == CMD_wgpuInstanceProcessEvents) {
		struct {
			WGPUInstance instance;
		} __attribute__((packed))* const args = data;

		wgpuInstanceProcessEvents(args->instance);
	}

	else if (cmd == CMD_wgpuInstanceRequestAdapter) {
		struct {
			WGPUInstance instance;
			WGPU_NULLABLE WGPURequestAdapterOptions const * options;
			WGPURequestAdapterCallback callback;
			void * userdata;
		} __attribute__((packed))* const args = data;

		wgpuInstanceRequestAdapter(args->instance, args->options, args->callback, args->userdata);
	}

	else if (cmd == CMD_wgpuInstanceReference) {
		struct {
			WGPUInstance instance;
		} __attribute__((packed))* const args = data;

		wgpuInstanceReference(args->instance);
	}

	else if (cmd == CMD_wgpuInstanceRelease) {
		struct {
			WGPUInstance instance;
		} __attribute__((packed))* const args = data;

		wgpuInstanceRelease(args->instance);
	}

	else if (cmd == CMD_wgpuPipelineLayoutSetLabel) {
		struct {
			WGPUPipelineLayout pipelineLayout;
			char const * label;
		} __attribute__((packed))* const args = data;

		wgpuPipelineLayoutSetLabel(args->pipelineLayout, args->label);
	}

	else if (cmd == CMD_wgpuPipelineLayoutReference) {
		struct {
			WGPUPipelineLayout pipelineLayout;
		} __attribute__((packed))* const args = data;

		wgpuPipelineLayoutReference(args->pipelineLayout);
	}

	else if (cmd == CMD_wgpuPipelineLayoutRelease) {
		struct {
			WGPUPipelineLayout pipelineLayout;
		} __attribute__((packed))* const args = data;

		wgpuPipelineLayoutRelease(args->pipelineLayout);
	}

	else if (cmd == CMD_wgpuQuerySetDestroy) {
		struct {
			WGPUQuerySet querySet;
		} __attribute__((packed))* const args = data;

		wgpuQuerySetDestroy(args->querySet);
	}

	else if (cmd == CMD_wgpuQuerySetGetCount) {
		struct {
			WGPUQuerySet querySet;
		} __attribute__((packed))* const args = data;

		return (uint64_t) wgpuQuerySetGetCount(args->querySet);
	}

	else if (cmd == CMD_wgpuQuerySetGetType) {
		struct {
			WGPUQuerySet querySet;
		} __attribute__((packed))* const args = data;

		return (uint64_t) wgpuQuerySetGetType(args->querySet);
	}

	else if (cmd == CMD_wgpuQuerySetSetLabel) {
		struct {
			WGPUQuerySet querySet;
			char const * label;
		} __attribute__((packed))* const args = data;

		wgpuQuerySetSetLabel(args->querySet, args->label);
	}

	else if (cmd == CMD_wgpuQuerySetReference) {
		struct {
			WGPUQuerySet querySet;
		} __attribute__((packed))* const args = data;

		wgpuQuerySetReference(args->querySet);
	}

	else if (cmd == CMD_wgpuQuerySetRelease) {
		struct {
			WGPUQuerySet querySet;
		} __attribute__((packed))* const args = data;

		wgpuQuerySetRelease(args->querySet);
	}

	else if (cmd == CMD_wgpuQueueOnSubmittedWorkDone) {
		struct {
			WGPUQueue queue;
			WGPUQueueWorkDoneCallback callback;
			void * userdata;
		} __attribute__((packed))* const args = data;

		wgpuQueueOnSubmittedWorkDone(args->queue, args->callback, args->userdata);
	}

	else if (cmd == CMD_wgpuQueueSetLabel) {
		struct {
			WGPUQueue queue;
			char const * label;
		} __attribute__((packed))* const args = data;

		wgpuQueueSetLabel(args->queue, args->label);
	}

	else if (cmd == CMD_wgpuQueueSubmit) {
		struct {
			WGPUQueue queue;
			size_t commandCount;
			WGPUCommandBuffer const * commands;
		} __attribute__((packed))* const args = data;

		wgpuQueueSubmit(args->queue, args->commandCount, args->commands);
	}

	else if (cmd == CMD_wgpuQueueWriteBuffer) {
		struct {
			WGPUQueue queue;
			WGPUBuffer buffer;
			uint64_t bufferOffset;
			void const * data;
			size_t size;
		} __attribute__((packed))* const args = data;

		wgpuQueueWriteBuffer(args->queue, args->buffer, args->bufferOffset, args->data, args->size);
	}

	else if (cmd == CMD_wgpuQueueWriteTexture) {
		struct {
			WGPUQueue queue;
			WGPUImageCopyTexture const * destination;
			void const * data;
			size_t dataSize;
			WGPUTextureDataLayout const * dataLayout;
			WGPUExtent3D const * writeSize;
		} __attribute__((packed))* const args = data;

		wgpuQueueWriteTexture(args->queue, args->destination, args->data, args->dataSize, args->dataLayout, args->writeSize);
	}

	else if (cmd == CMD_wgpuQueueReference) {
		struct {
			WGPUQueue queue;
		} __attribute__((packed))* const args = data;

		wgpuQueueReference(args->queue);
	}

	else if (cmd == CMD_wgpuQueueRelease) {
		struct {
			WGPUQueue queue;
		} __attribute__((packed))* const args = data;

		wgpuQueueRelease(args->queue);
	}

	else if (cmd == CMD_wgpuRenderBundleSetLabel) {
		struct {
			WGPURenderBundle renderBundle;
			char const * label;
		} __attribute__((packed))* const args = data;

		wgpuRenderBundleSetLabel(args->renderBundle, args->label);
	}

	else if (cmd == CMD_wgpuRenderBundleReference) {
		struct {
			WGPURenderBundle renderBundle;
		} __attribute__((packed))* const args = data;

		wgpuRenderBundleReference(args->renderBundle);
	}

	else if (cmd == CMD_wgpuRenderBundleRelease) {
		struct {
			WGPURenderBundle renderBundle;
		} __attribute__((packed))* const args = data;

		wgpuRenderBundleRelease(args->renderBundle);
	}

	else if (cmd == CMD_wgpuRenderBundleEncoderDraw) {
		struct {
			WGPURenderBundleEncoder renderBundleEncoder;
			uint32_t vertexCount;
			uint32_t instanceCount;
			uint32_t firstVertex;
			uint32_t firstInstance;
		} __attribute__((packed))* const args = data;

		wgpuRenderBundleEncoderDraw(args->renderBundleEncoder, args->vertexCount, args->instanceCount, args->firstVertex, args->firstInstance);
	}

	else if (cmd == CMD_wgpuRenderBundleEncoderDrawIndexed) {
		struct {
			WGPURenderBundleEncoder renderBundleEncoder;
			uint32_t indexCount;
			uint32_t instanceCount;
			uint32_t firstIndex;
			int32_t baseVertex;
			uint32_t firstInstance;
		} __attribute__((packed))* const args = data;

		wgpuRenderBundleEncoderDrawIndexed(args->renderBundleEncoder, args->indexCount, args->instanceCount, args->firstIndex, args->baseVertex, args->firstInstance);
	}

	else if (cmd == CMD_wgpuRenderBundleEncoderDrawIndexedIndirect) {
		struct {
			WGPURenderBundleEncoder renderBundleEncoder;
			WGPUBuffer indirectBuffer;
			uint64_t indirectOffset;
		} __attribute__((packed))* const args = data;

		wgpuRenderBundleEncoderDrawIndexedIndirect(args->renderBundleEncoder, args->indirectBuffer, args->indirectOffset);
	}

	else if (cmd == CMD_wgpuRenderBundleEncoderDrawIndirect) {
		struct {
			WGPURenderBundleEncoder renderBundleEncoder;
			WGPUBuffer indirectBuffer;
			uint64_t indirectOffset;
		} __attribute__((packed))* const args = data;

		wgpuRenderBundleEncoderDrawIndirect(args->renderBundleEncoder, args->indirectBuffer, args->indirectOffset);
	}

	else if (cmd == CMD_wgpuRenderBundleEncoderFinish) {
		struct {
			WGPURenderBundleEncoder renderBundleEncoder;
			WGPU_NULLABLE WGPURenderBundleDescriptor const * descriptor;
		} __attribute__((packed))* const args = data;

		return (uint64_t) wgpuRenderBundleEncoderFinish(args->renderBundleEncoder, args->descriptor);
	}

	else if (cmd == CMD_wgpuRenderBundleEncoderInsertDebugMarker) {
		struct {
			WGPURenderBundleEncoder renderBundleEncoder;
			char const * markerLabel;
		} __attribute__((packed))* const args = data;

		wgpuRenderBundleEncoderInsertDebugMarker(args->renderBundleEncoder, args->markerLabel);
	}

	else if (cmd == CMD_wgpuRenderBundleEncoderPopDebugGroup) {
		struct {
			WGPURenderBundleEncoder renderBundleEncoder;
		} __attribute__((packed))* const args = data;

		wgpuRenderBundleEncoderPopDebugGroup(args->renderBundleEncoder);
	}

	else if (cmd == CMD_wgpuRenderBundleEncoderPushDebugGroup) {
		struct {
			WGPURenderBundleEncoder renderBundleEncoder;
			char const * groupLabel;
		} __attribute__((packed))* const args = data;

		wgpuRenderBundleEncoderPushDebugGroup(args->renderBundleEncoder, args->groupLabel);
	}

	else if (cmd == CMD_wgpuRenderBundleEncoderSetBindGroup) {
		struct {
			WGPURenderBundleEncoder renderBundleEncoder;
			uint32_t groupIndex;
			WGPU_NULLABLE WGPUBindGroup group;
			size_t dynamicOffsetCount;
			uint32_t const * dynamicOffsets;
		} __attribute__((packed))* const args = data;

		wgpuRenderBundleEncoderSetBindGroup(args->renderBundleEncoder, args->groupIndex, args->group, args->dynamicOffsetCount, args->dynamicOffsets);
	}

	else if (cmd == CMD_wgpuRenderBundleEncoderSetIndexBuffer) {
		struct {
			WGPURenderBundleEncoder renderBundleEncoder;
			WGPUBuffer buffer;
			WGPUIndexFormat format;
			uint64_t offset;
			uint64_t size;
		} __attribute__((packed))* const args = data;

		wgpuRenderBundleEncoderSetIndexBuffer(args->renderBundleEncoder, args->buffer, args->format, args->offset, args->size);
	}

	else if (cmd == CMD_wgpuRenderBundleEncoderSetLabel) {
		struct {
			WGPURenderBundleEncoder renderBundleEncoder;
			char const * label;
		} __attribute__((packed))* const args = data;

		wgpuRenderBundleEncoderSetLabel(args->renderBundleEncoder, args->label);
	}

	else if (cmd == CMD_wgpuRenderBundleEncoderSetPipeline) {
		struct {
			WGPURenderBundleEncoder renderBundleEncoder;
			WGPURenderPipeline pipeline;
		} __attribute__((packed))* const args = data;

		wgpuRenderBundleEncoderSetPipeline(args->renderBundleEncoder, args->pipeline);
	}

	else if (cmd == CMD_wgpuRenderBundleEncoderSetVertexBuffer) {
		struct {
			WGPURenderBundleEncoder renderBundleEncoder;
			uint32_t slot;
			WGPU_NULLABLE WGPUBuffer buffer;
			uint64_t offset;
			uint64_t size;
		} __attribute__((packed))* const args = data;

		wgpuRenderBundleEncoderSetVertexBuffer(args->renderBundleEncoder, args->slot, args->buffer, args->offset, args->size);
	}

	else if (cmd == CMD_wgpuRenderBundleEncoderReference) {
		struct {
			WGPURenderBundleEncoder renderBundleEncoder;
		} __attribute__((packed))* const args = data;

		wgpuRenderBundleEncoderReference(args->renderBundleEncoder);
	}

	else if (cmd == CMD_wgpuRenderBundleEncoderRelease) {
		struct {
			WGPURenderBundleEncoder renderBundleEncoder;
		} __attribute__((packed))* const args = data;

		wgpuRenderBundleEncoderRelease(args->renderBundleEncoder);
	}

	else if (cmd == CMD_wgpuRenderPassEncoderBeginOcclusionQuery) {
		struct {
			WGPURenderPassEncoder renderPassEncoder;
			uint32_t queryIndex;
		} __attribute__((packed))* const args = data;

		wgpuRenderPassEncoderBeginOcclusionQuery(args->renderPassEncoder, args->queryIndex);
	}

	else if (cmd == CMD_wgpuRenderPassEncoderBeginPipelineStatisticsQuery) {
		struct {
			WGPURenderPassEncoder renderPassEncoder;
			WGPUQuerySet querySet;
			uint32_t queryIndex;
		} __attribute__((packed))* const args = data;

		wgpuRenderPassEncoderBeginPipelineStatisticsQuery(args->renderPassEncoder, args->querySet, args->queryIndex);
	}

	else if (cmd == CMD_wgpuRenderPassEncoderDraw) {
		struct {
			WGPURenderPassEncoder renderPassEncoder;
			uint32_t vertexCount;
			uint32_t instanceCount;
			uint32_t firstVertex;
			uint32_t firstInstance;
		} __attribute__((packed))* const args = data;

		wgpuRenderPassEncoderDraw(args->renderPassEncoder, args->vertexCount, args->instanceCount, args->firstVertex, args->firstInstance);
	}

	else if (cmd == CMD_wgpuRenderPassEncoderDrawIndexed) {
		struct {
			WGPURenderPassEncoder renderPassEncoder;
			uint32_t indexCount;
			uint32_t instanceCount;
			uint32_t firstIndex;
			int32_t baseVertex;
			uint32_t firstInstance;
		} __attribute__((packed))* const args = data;

		wgpuRenderPassEncoderDrawIndexed(args->renderPassEncoder, args->indexCount, args->instanceCount, args->firstIndex, args->baseVertex, args->firstInstance);
	}

	else if (cmd == CMD_wgpuRenderPassEncoderDrawIndexedIndirect) {
		struct {
			WGPURenderPassEncoder renderPassEncoder;
			WGPUBuffer indirectBuffer;
			uint64_t indirectOffset;
		} __attribute__((packed))* const args = data;

		wgpuRenderPassEncoderDrawIndexedIndirect(args->renderPassEncoder, args->indirectBuffer, args->indirectOffset);
	}

	else if (cmd == CMD_wgpuRenderPassEncoderDrawIndirect) {
		struct {
			WGPURenderPassEncoder renderPassEncoder;
			WGPUBuffer indirectBuffer;
			uint64_t indirectOffset;
		} __attribute__((packed))* const args = data;

		wgpuRenderPassEncoderDrawIndirect(args->renderPassEncoder, args->indirectBuffer, args->indirectOffset);
	}

	else if (cmd == CMD_wgpuRenderPassEncoderEnd) {
		struct {
			WGPURenderPassEncoder renderPassEncoder;
		} __attribute__((packed))* const args = data;

		wgpuRenderPassEncoderEnd(args->renderPassEncoder);
	}

	else if (cmd == CMD_wgpuRenderPassEncoderEndOcclusionQuery) {
		struct {
			WGPURenderPassEncoder renderPassEncoder;
		} __attribute__((packed))* const args = data;

		wgpuRenderPassEncoderEndOcclusionQuery(args->renderPassEncoder);
	}

	else if (cmd == CMD_wgpuRenderPassEncoderEndPipelineStatisticsQuery) {
		struct {
			WGPURenderPassEncoder renderPassEncoder;
		} __attribute__((packed))* const args = data;

		wgpuRenderPassEncoderEndPipelineStatisticsQuery(args->renderPassEncoder);
	}

	else if (cmd == CMD_wgpuRenderPassEncoderExecuteBundles) {
		struct {
			WGPURenderPassEncoder renderPassEncoder;
			size_t bundleCount;
			WGPURenderBundle const * bundles;
		} __attribute__((packed))* const args = data;

		wgpuRenderPassEncoderExecuteBundles(args->renderPassEncoder, args->bundleCount, args->bundles);
	}

	else if (cmd == CMD_wgpuRenderPassEncoderInsertDebugMarker) {
		struct {
			WGPURenderPassEncoder renderPassEncoder;
			char const * markerLabel;
		} __attribute__((packed))* const args = data;

		wgpuRenderPassEncoderInsertDebugMarker(args->renderPassEncoder, args->markerLabel);
	}

	else if (cmd == CMD_wgpuRenderPassEncoderPopDebugGroup) {
		struct {
			WGPURenderPassEncoder renderPassEncoder;
		} __attribute__((packed))* const args = data;

		wgpuRenderPassEncoderPopDebugGroup(args->renderPassEncoder);
	}

	else if (cmd == CMD_wgpuRenderPassEncoderPushDebugGroup) {
		struct {
			WGPURenderPassEncoder renderPassEncoder;
			char const * groupLabel;
		} __attribute__((packed))* const args = data;

		wgpuRenderPassEncoderPushDebugGroup(args->renderPassEncoder, args->groupLabel);
	}

	else if (cmd == CMD_wgpuRenderPassEncoderSetBindGroup) {
		struct {
			WGPURenderPassEncoder renderPassEncoder;
			uint32_t groupIndex;
			WGPU_NULLABLE WGPUBindGroup group;
			size_t dynamicOffsetCount;
			uint32_t const * dynamicOffsets;
		} __attribute__((packed))* const args = data;

		wgpuRenderPassEncoderSetBindGroup(args->renderPassEncoder, args->groupIndex, args->group, args->dynamicOffsetCount, args->dynamicOffsets);
	}

	else if (cmd == CMD_wgpuRenderPassEncoderSetBlendConstant) {
		struct {
			WGPURenderPassEncoder renderPassEncoder;
			WGPUColor const * color;
		} __attribute__((packed))* const args = data;

		wgpuRenderPassEncoderSetBlendConstant(args->renderPassEncoder, args->color);
	}

	else if (cmd == CMD_wgpuRenderPassEncoderSetIndexBuffer) {
		struct {
			WGPURenderPassEncoder renderPassEncoder;
			WGPUBuffer buffer;
			WGPUIndexFormat format;
			uint64_t offset;
			uint64_t size;
		} __attribute__((packed))* const args = data;

		wgpuRenderPassEncoderSetIndexBuffer(args->renderPassEncoder, args->buffer, args->format, args->offset, args->size);
	}

	else if (cmd == CMD_wgpuRenderPassEncoderSetLabel) {
		struct {
			WGPURenderPassEncoder renderPassEncoder;
			char const * label;
		} __attribute__((packed))* const args = data;

		wgpuRenderPassEncoderSetLabel(args->renderPassEncoder, args->label);
	}

	else if (cmd == CMD_wgpuRenderPassEncoderSetPipeline) {
		struct {
			WGPURenderPassEncoder renderPassEncoder;
			WGPURenderPipeline pipeline;
		} __attribute__((packed))* const args = data;

		wgpuRenderPassEncoderSetPipeline(args->renderPassEncoder, args->pipeline);
	}

	else if (cmd == CMD_wgpuRenderPassEncoderSetScissorRect) {
		struct {
			WGPURenderPassEncoder renderPassEncoder;
			uint32_t x;
			uint32_t y;
			uint32_t width;
			uint32_t height;
		} __attribute__((packed))* const args = data;

		wgpuRenderPassEncoderSetScissorRect(args->renderPassEncoder, args->x, args->y, args->width, args->height);
	}

	else if (cmd == CMD_wgpuRenderPassEncoderSetStencilReference) {
		struct {
			WGPURenderPassEncoder renderPassEncoder;
			uint32_t reference;
		} __attribute__((packed))* const args = data;

		wgpuRenderPassEncoderSetStencilReference(args->renderPassEncoder, args->reference);
	}

	else if (cmd == CMD_wgpuRenderPassEncoderSetVertexBuffer) {
		struct {
			WGPURenderPassEncoder renderPassEncoder;
			uint32_t slot;
			WGPU_NULLABLE WGPUBuffer buffer;
			uint64_t offset;
			uint64_t size;
		} __attribute__((packed))* const args = data;

		wgpuRenderPassEncoderSetVertexBuffer(args->renderPassEncoder, args->slot, args->buffer, args->offset, args->size);
	}

	else if (cmd == CMD_wgpuRenderPassEncoderSetViewport) {
		struct {
			WGPURenderPassEncoder renderPassEncoder;
			float x;
			float y;
			float width;
			float height;
			float minDepth;
			float maxDepth;
		} __attribute__((packed))* const args = data;

		wgpuRenderPassEncoderSetViewport(args->renderPassEncoder, args->x, args->y, args->width, args->height, args->minDepth, args->maxDepth);
	}

	else if (cmd == CMD_wgpuRenderPassEncoderReference) {
		struct {
			WGPURenderPassEncoder renderPassEncoder;
		} __attribute__((packed))* const args = data;

		wgpuRenderPassEncoderReference(args->renderPassEncoder);
	}

	else if (cmd == CMD_wgpuRenderPassEncoderRelease) {
		struct {
			WGPURenderPassEncoder renderPassEncoder;
		} __attribute__((packed))* const args = data;

		wgpuRenderPassEncoderRelease(args->renderPassEncoder);
	}

	else if (cmd == CMD_wgpuRenderPipelineGetBindGroupLayout) {
		struct {
			WGPURenderPipeline renderPipeline;
			uint32_t groupIndex;
		} __attribute__((packed))* const args = data;

		return (uint64_t) wgpuRenderPipelineGetBindGroupLayout(args->renderPipeline, args->groupIndex);
	}

	else if (cmd == CMD_wgpuRenderPipelineSetLabel) {
		struct {
			WGPURenderPipeline renderPipeline;
			char const * label;
		} __attribute__((packed))* const args = data;

		wgpuRenderPipelineSetLabel(args->renderPipeline, args->label);
	}

	else if (cmd == CMD_wgpuRenderPipelineReference) {
		struct {
			WGPURenderPipeline renderPipeline;
		} __attribute__((packed))* const args = data;

		wgpuRenderPipelineReference(args->renderPipeline);
	}

	else if (cmd == CMD_wgpuRenderPipelineRelease) {
		struct {
			WGPURenderPipeline renderPipeline;
		} __attribute__((packed))* const args = data;

		wgpuRenderPipelineRelease(args->renderPipeline);
	}

	else if (cmd == CMD_wgpuSamplerSetLabel) {
		struct {
			WGPUSampler sampler;
			char const * label;
		} __attribute__((packed))* const args = data;

		wgpuSamplerSetLabel(args->sampler, args->label);
	}

	else if (cmd == CMD_wgpuSamplerReference) {
		struct {
			WGPUSampler sampler;
		} __attribute__((packed))* const args = data;

		wgpuSamplerReference(args->sampler);
	}

	else if (cmd == CMD_wgpuSamplerRelease) {
		struct {
			WGPUSampler sampler;
		} __attribute__((packed))* const args = data;

		wgpuSamplerRelease(args->sampler);
	}

	else if (cmd == CMD_wgpuShaderModuleGetCompilationInfo) {
		struct {
			WGPUShaderModule shaderModule;
			WGPUCompilationInfoCallback callback;
			void * userdata;
		} __attribute__((packed))* const args = data;

		wgpuShaderModuleGetCompilationInfo(args->shaderModule, args->callback, args->userdata);
	}

	else if (cmd == CMD_wgpuShaderModuleSetLabel) {
		struct {
			WGPUShaderModule shaderModule;
			char const * label;
		} __attribute__((packed))* const args = data;

		wgpuShaderModuleSetLabel(args->shaderModule, args->label);
	}

	else if (cmd == CMD_wgpuShaderModuleReference) {
		struct {
			WGPUShaderModule shaderModule;
		} __attribute__((packed))* const args = data;

		wgpuShaderModuleReference(args->shaderModule);
	}

	else if (cmd == CMD_wgpuShaderModuleRelease) {
		struct {
			WGPUShaderModule shaderModule;
		} __attribute__((packed))* const args = data;

		wgpuShaderModuleRelease(args->shaderModule);
	}

	else if (cmd == CMD_wgpuSurfaceGetPreferredFormat) {
		struct {
			WGPUSurface surface;
			WGPUAdapter adapter;
		} __attribute__((packed))* const args = data;

		return (uint64_t) wgpuSurfaceGetPreferredFormat(args->surface, args->adapter);
	}

	else if (cmd == CMD_wgpuSurfaceReference) {
		struct {
			WGPUSurface surface;
		} __attribute__((packed))* const args = data;

		wgpuSurfaceReference(args->surface);
	}

	else if (cmd == CMD_wgpuSurfaceRelease) {
		struct {
			WGPUSurface surface;
		} __attribute__((packed))* const args = data;

		wgpuSurfaceRelease(args->surface);
	}

	else if (cmd == CMD_wgpuSwapChainGetCurrentTextureView) {
		struct {
			WGPUSwapChain swapChain;
		} __attribute__((packed))* const args = data;

		return (uint64_t) wgpuSwapChainGetCurrentTextureView(args->swapChain);
	}

	else if (cmd == CMD_wgpuSwapChainPresent) {
		struct {
			WGPUSwapChain swapChain;
		} __attribute__((packed))* const args = data;

		wgpuSwapChainPresent(args->swapChain);
	}

	else if (cmd == CMD_wgpuSwapChainReference) {
		struct {
			WGPUSwapChain swapChain;
		} __attribute__((packed))* const args = data;

		wgpuSwapChainReference(args->swapChain);
	}

	else if (cmd == CMD_wgpuSwapChainRelease) {
		struct {
			WGPUSwapChain swapChain;
		} __attribute__((packed))* const args = data;

		wgpuSwapChainRelease(args->swapChain);
	}

	else if (cmd == CMD_wgpuTextureCreateView) {
		struct {
			WGPUTexture texture;
			WGPU_NULLABLE WGPUTextureViewDescriptor const * descriptor;
		} __attribute__((packed))* const args = data;

		return (uint64_t) wgpuTextureCreateView(args->texture, args->descriptor);
	}

	else if (cmd == CMD_wgpuTextureDestroy) {
		struct {
			WGPUTexture texture;
		} __attribute__((packed))* const args = data;

		wgpuTextureDestroy(args->texture);
	}

	else if (cmd == CMD_wgpuTextureGetDepthOrArrayLayers) {
		struct {
			WGPUTexture texture;
		} __attribute__((packed))* const args = data;

		return (uint64_t) wgpuTextureGetDepthOrArrayLayers(args->texture);
	}

	else if (cmd == CMD_wgpuTextureGetDimension) {
		struct {
			WGPUTexture texture;
		} __attribute__((packed))* const args = data;

		return (uint64_t) wgpuTextureGetDimension(args->texture);
	}

	else if (cmd == CMD_wgpuTextureGetFormat) {
		struct {
			WGPUTexture texture;
		} __attribute__((packed))* const args = data;

		return (uint64_t) wgpuTextureGetFormat(args->texture);
	}

	else if (cmd == CMD_wgpuTextureGetHeight) {
		struct {
			WGPUTexture texture;
		} __attribute__((packed))* const args = data;

		return (uint64_t) wgpuTextureGetHeight(args->texture);
	}

	else if (cmd == CMD_wgpuTextureGetMipLevelCount) {
		struct {
			WGPUTexture texture;
		} __attribute__((packed))* const args = data;

		return (uint64_t) wgpuTextureGetMipLevelCount(args->texture);
	}

	else if (cmd == CMD_wgpuTextureGetSampleCount) {
		struct {
			WGPUTexture texture;
		} __attribute__((packed))* const args = data;

		return (uint64_t) wgpuTextureGetSampleCount(args->texture);
	}

	else if (cmd == CMD_wgpuTextureGetUsage) {
		struct {
			WGPUTexture texture;
		} __attribute__((packed))* const args = data;

		return (uint64_t) wgpuTextureGetUsage(args->texture);
	}

	else if (cmd == CMD_wgpuTextureGetWidth) {
		struct {
			WGPUTexture texture;
		} __attribute__((packed))* const args = data;

		return (uint64_t) wgpuTextureGetWidth(args->texture);
	}

	else if (cmd == CMD_wgpuTextureSetLabel) {
		struct {
			WGPUTexture texture;
			char const * label;
		} __attribute__((packed))* const args = data;

		wgpuTextureSetLabel(args->texture, args->label);
	}

	else if (cmd == CMD_wgpuTextureReference) {
		struct {
			WGPUTexture texture;
		} __attribute__((packed))* const args = data;

		wgpuTextureReference(args->texture);
	}

	else if (cmd == CMD_wgpuTextureRelease) {
		struct {
			WGPUTexture texture;
		} __attribute__((packed))* const args = data;

		wgpuTextureRelease(args->texture);
	}

	else if (cmd == CMD_wgpuTextureViewSetLabel) {
		struct {
			WGPUTextureView textureView;
			char const * label;
		} __attribute__((packed))* const args = data;

		wgpuTextureViewSetLabel(args->textureView, args->label);
	}

	else if (cmd == CMD_wgpuTextureViewReference) {
		struct {
			WGPUTextureView textureView;
		} __attribute__((packed))* const args = data;

		wgpuTextureViewReference(args->textureView);
	}

	else if (cmd == CMD_wgpuTextureViewRelease) {
		struct {
			WGPUTextureView textureView;
		} __attribute__((packed))* const args = data;

		wgpuTextureViewRelease(args->textureView);
	}

	return -1;
}
